---
title: Basic data structures
date: 2019-12-28
---

# TIL Stack and Queue

## Stack

스택은 LIFO(Last in, first out) 순서를 따르는 데이터 구조다. 스택에는 세 가지 주요 방법이 있다.
* Push()
    * 스택의 맨 위에 요소 추가
* Pop()
    * 스택 상단에서 요소 제거
* Peek()
    * 스택에 영향을 주지 않고 스택 내부의 최상위 요소 반환

```jsx
class stack {
  constructor() {  
		this.items = [];
  }
		push(a){this.items.push(a)}
	 pop() {this.items.pop()}
		peek() {return this.items[this.items.length-1]}
}
let a = new stack();
a.push('rock');
a.push('dirt');
a.push('grass');

a // the instance returns a property array with [ “rock”, “dirt”, “grass” ]

a.pop(); // pops the newest added element (“grass”)
a // the instance returns a property array with [ “rock”, “dirt” ]

a.peek(); // returns “dirt”, the last element in the array   
```

스택 데이터 구조의 시각적 예는 땅에 구멍을 파는 것이다. 하층(선입)을 제거하려면 먼저 지구의 가장 바깥쪽 층(마지막 안)을 제거해야 한다.

![]("/content/assets/stack data structure.png")


## Queue

큐는 선형적으로 배열된 단순한 데이터 구조다. 스택과 달리 큐는 FIFO(선입선출, 선입선출) 순서로 작동한다. 이것은 추가된 가장 오래된 요소가 새로운 요소보다 먼저 제거됨을 의미한다. Javascript에서 큐는 어레이 메서드 pop()과 unshift()로 구현할 수 있다. 큐에는 어레이에서 가장 오래된 값을 반환하기 위한 peek() 방법도 포함되어 있다.

* pop()
    * Dequeue
* unshift()
    * Enquue
* peek()
    * 배열에서 가장 오래된 값(다음으로 튀겨짐)을 반환한다.

```jsx
class Queue {
    constructor() {
            this.data = [];
    }
    enqueue(a) {this.data.unshift(a);}
    dequeue() {this.data.pop();}
    peek() {return this.data[this.data.length - 1];}
}

var e = new Queue()
e.enqueue(1);
e.enqueue(2);
e.enqueue(3);
e.enqueue(4);

e //  data property array contains [ 4, 3, 2, 1]

e.dequeue(); // removes 1 from the array

e.peek(); // returns 2
```

큐 데이터 구조를 시각적으로 생각해보면 다이빙 보드의 라인업을 상상할 수 있다. 각 잠수부들은 줄을 서서 줄을 서고, 줄에 있는 첫 번째 잠수부들은 다음 사람들이 차례대로 돌아가기 전에 보드에서 뛰어내려야 한다.

![]("/content/assets/queue data structure.png")