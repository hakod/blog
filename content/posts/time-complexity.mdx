---
title: Time complexity
date: 2020-01-02
---


## What is Time complexity

시간 복잡성은 입력 n에 주어진 알고리즘을 실행하는 데 걸리는 시간이다. 알고리즘은 많은 입력을 받게 되며, 각각의 작동은 완료하는 데 약간 또는 많은 시간을 추가할 수 있다. 이것은 알고리즘의 속도를 최적화하는데 중요하다. 최악의 경우 시간 복잡성은 모든 입력을 조작해야 할 경우 알고리즘이 소요되는 최대 시간을 정의한다. Big O 표기법은 입력 크기가 커질수록 시간 복잡성이 증가하는 대략적인 속도를 나타내며, 이는 가장 느린 속도에서 가장 빠른 속도로 분류된다.
* 상수: O(1)
    * 배열지수 값
* 로그: O(log n)
    * 예:이진검색
* 선형: O(n)
    * 예:연계리스트 조회
* 2차: O(n^2)
    * 예: 균일하게 내포된 루프용 런닝
* 지수: O(c^n)
    * 예: 최단 경로를 찾기 위한 출장 판매원(그래프 횡단)
    * 그래프의 각 꼭지점 1회 방문

### Constant time O(1)

알고리즘은 입력 크기에 따라 증가하지 않는다. 예를 들어, 지정된 인덱스의 배열 할당에는 할당된 어레이의 크기에 영향을 받지 않고 할당 작업이 변경되지 않기 때문에 일정한 시간이 걸릴 수 있다. 주어진 지수와 홀로 남겨진 다른 지수로만 할당 작업을 수행한다.


### Logarithmic time O(log n)

로가리듬 시간을 갖는 알고리즘은 입력 크기(n)가 증가함에 따라 필요한 작업이 더 적은 속도로 증가하기 때문에 빠른 시간 복잡성으로 간주된다. 이것의 예는 균형 잡힌 BST 찾기 작업에서 볼 수 있다. 트리는 항상 왼쪽과 오른쪽으로 나뉘기 때문에 각 단계에서 체크인해야 하는 입력 크기를 반으로 줄여 필요한 작업 수를 줄인다.


### Linear time O(n)

선형 시간이 걸리는 알고리즘은 입력 크기가 증가하는 속도와 거의 동일한 속도로 시간의 복잡성을 증가시킨다. 이는 어레이의 각 인덱스를 검사하여 일치하는 값을 찾아야 하는 find와 같은 어레이 작업에서 가장 일반적으로 볼 수 있다.


### Quadratic time O(n^2)

2차 시간 알고리즘의 시간 복잡성은 입력의 성장보다 더 빠르게 증가한다. 이는 n이 성장함에 따라 n에 n을 곱한 산물이 훨씬 큰 속도로 증가하기 때문이다. 


### Exponential time O(c^n)

입력 크기가 커짐에 따라 2차 시간이 걸리는 알고리즘은 처리 시간이 훨씬 더 오래 걸린다. 위에서 언급했듯이, 여행 판매원 문제는 일반적으로 지수적인 시간이 걸리는 알고리즘을 채택할 것이다. 그래프에서 정점이 여러 개 있는 경우, 각 정점을 한 번 방문한 곳에서 가장 짧은 경로를 찾아야 한다. 이 문제는 가능한 모든 경로를 처리하고 가장 짧은 경로를 선택해야 하므로 지수 시간이 필요하다. 예를 들어, 정점이 9개인 그래프는 362880개의 서로 다른 경로를 가질 것이다.


## Data structure time complexity

각 데이터 구조 작업의 시간 복잡성을 이해하면 특정 알고리즘에 필요한 데이터 구조를 결정하는 데 도움이 될 수 있다.

### Array
* 조회: O(1)
* 할당: O(1)
* 삽입: O(n)
* 제거: O(n)
* 찾기: O(n)

### Linked list
* 조회: O(n)
* 찾기: O(n)
* 할당: O(n)
* 삽입: O(1)
* 머리 제거: O(1)
* 중간에서 제거: O(n)


### Doubly linked list
* 중간 제거: O(1)


### Tree
* DFS 찾기: O(n)


### BST
* 찾기(균형 트리: 높이 = 로그 n): O(log n)
* 찾기(균형 없는 트리): O(n)