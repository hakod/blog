---
title: Advanced data structures
date: 2019-12-30
---

# TIL Advanced data structures

## Linked List

Linked List는 동일한 메모리 위치로 제한되지 않는 선형 데이터 구조. 연결된 목록은 머리(목록의 첫 번째 노드)와 연결된 노드로 구성된다. 각 노드는 포인터를 사용하여 목록의 다음 노드를 가리키며, 목록의 각 노드는 자체 데이터를 포함하고 있다. Linked List를 사용하면 포인터로 인해 일반 어레이보다 두 노드 사이에 새 노드를 쉽게 추가할 수 있다.

Linked List에는 다음과 같은 방법이 있다:
* add(node)
    * 리스트의 꼬리끝에 새로운 노드를 추가
* remove(index)
    * 명단에서 헤드노드 제거
* contains(element)
    * 연계 목록에 소자가 포함되어 있을 경우 true로 한다


```jsx
// LinkedList constructor for head
	// create empty object ‘list’
	// add ‘head’ to list equal null
	// add ‘tail’ to list equal null

	// add method to list ‘addToTail’ to add new element
			// create new node with data
			// loop through tail until null is found
			// add new node to tail
	// add method ‘removeHead’ which deletes head element
			// make the second element in the list into head
			// return head
	// add method ‘contains’ to check if list contains specified element
			// loop through list until end, return true if element is found
			// return false
	// return the list

// Node for new node
	// create node object

	// add to node ‘value’
	// add to node ‘next’ (pointer)

	// return node;
```


## Graph

Graph는 노드와 가장자리로 이루어진 비선형 데이터 구조다. 가장자리는 노드 간의 연결이다. 이 데이터 구조는 비선형이며, 이는 노드 간의 연결이 어느 쪽으로든 갈 수 있고, 삽입 및 삭제가 순차적이지 않다는 것을 의미한다. 그래프 방법:
* addNode(node)
    * 새 노드 추가
* addEdge(start, to)
    * 2개 노드의 연결부 추가
* removeNode(node)
    * 노드를 제거
* removeEdge (from, to)
    * 2개 노드의 연결부 제거
* contains(node)
    * 노드가 그래프에 포함된 경우 true를 반환함


```jsx
// Graph constructor
	// add vertex method
			// insert vertex in Map object with value and array of edges connected
	// contains method
			// search value in Map object, return true if found
	// remove node method
			// find value and delete
	// addEdge method
			// find values connected from list and add each other’s value into their arrays
```


## Tree

트리(tree)는 또한 그래프와 유사한 비선형 데이터 구조로, 방향(한 방향으로만 이동할 수 있음)과 순환(동일한 노드로 두 번 이동하지 않음)이다. 루트 및 하위 노드 집합으로 구성됨. 트리의 각 노드는 자체 하위 노드를 포함할 수 있다.

* addChild(node)
    * 트리에 새 자식 노드 추가
* contains(node)
    * 나무 안에서 노드가 발견되면 true를 반환한다.


```jsx
// Tree constructor
	// create ‘root’ property with first value
	// create ‘children’ property with empty array

	// add method addChild
			//  push child elements into tree node
	// add method contains
			// loop through children array and search element
```


## Binary search tree

이진 검색 트리는 추가 속성을 가진 트리 데이터 구조다. BST의 각 노드는 왼쪽 아이가 상위 키보다 작은 키 값을 갖는 방식으로 정렬되어야 하며, 오른쪽 노드는 상위 키 값보다 큰 키 값을 가져야 한다.
* add(node)
* remove(node)


```jsx
// Tree constructor
	// create ‘root’ property with first value
	// create ‘children’ property with empty array

	// add method insert
			// compare new value to root value
			// if higher than root, search right
			// if lower than root, search left
			// insert value if ‘children’ property length is less than two
	// add method contains
			// compare search value to root
			// root becomes right node if value is higher
			// root becomes left node if value is lower
			// is value is found, return true
```


## Hash table

해시 테이블은 키를 값에 매핑하는 데이터 구조다. 해시 값은 각 값에 할당되어 해시 테이블 데이터 구조 내부에 저장된다. 해시함수의 이용을 통해 해시표 안에서 키의 인덱스를 발견한다. 해시함수는 데이터를 지도한다.
* insert(key, value)
    * 해시표에 키와 값을 삽입한다.
* remove(key)
    *기호 및 지정값
* retrieve(key)
    * 지정키에 설정된 값 검색


```jsx
// HashTable constructor

// add insert method to hashtable
	// run hashing function to generate index
		// push value into storage at hashed index

// add retrieve method to hashtable
	// run hashing function to generate index
	// return value found at index

// add remove method to hashtable
	// run hashing function to generate index
	// delete element at index
```