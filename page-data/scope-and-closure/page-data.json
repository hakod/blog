{"componentChunkName":"component---node-modules-gatsby-theme-blog-src-templates-post-js","path":"/scope-and-closure","webpackCompilationHash":"076c417a18adfc05b38b","result":{"data":{"post":{"id":"45b6317f-d19a-53a2-8819-c3dd7e871b5e","title":"Scope and Closure","date":"October 21, 2019","excerpt":"What is Closure Closure allows a function to reference values outside its scope. Closure is the function and its local variables stored for…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Scope and Closure\",\n  \"date\": \"2019-10-21T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"what-is-closure\"\n  }, \"What is Closure\"), mdx(\"p\", null, \"Closure allows a function to reference values outside its scope.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"function a() {\\n  let v = 5;\\n  function add() {\\n    return v + 2;\\n  }\\n  return add();\\n};\\n\\n// v is a local variable inside function a\\n// function add has access to v, a variable contained in an scope\\n\\n\")), mdx(\"p\", null, \"Closure is the function and its local variables stored for usage outside of its local scope. An example of this can be seen in currying. \"), mdx(\"p\", null, \"Currying example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"function div(x) {\\n  let a = function divisor(y) {\\n    return x / y;\\n  }\\n  return a;\\n};\\nlet divide10 = div(10);\\ndivide10(2) // returns 5\\ndivide10(5) // returns 2\\n\")), mdx(\"p\", null, \"The x value in divide10 is a closure (containing the variable assigned inside the lexical environment). Function divide10 can then be called with any value of y and return the correct results.\"), mdx(\"h2\", {\n    \"id\": \"module-pattern\"\n  }, \"module pattern\"), mdx(\"p\", null, \"Module pattern is a common usage of closure allowing outside functions to utilize inner functions and variables.\\nClosure allows the creation of private methods which block access to inner code and make a cleaner global namespace.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"function priv() {\\n  let innerString = 'Hello!'\\n  return {\\n    hi: function() {\\n      innerString = 'Hi!';\\n    },\\n    bye: function() {\\n      innerString = 'Bye';\\n    },\\n    greet: function() {\\n      return innerString;\\n    }\\n  }\\n}\\nlet bye = priv(); // creating a new closure with independent lexical environment\\nlet hi = priv() // another independent closure\\n\\nbye.bye(); // function bye is called changing the innerString to 'Bye!'\\nhi.hi(); // function hi called changing innerString to 'Hi!'\\n\\nbye.greet(); // returns \\\"Bye!\\\"\\nhi.greet(); // returns 'Hi!'\\n\")), mdx(\"h2\", {\n    \"id\": \"closure-scope\"\n  }, \"Closure Scope\"), mdx(\"p\", null, \"All closures have three scopes. The local scope, outer function scope, and the global scope. Closure can access data in each layer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// global scope\\nfunction div(x) {\\n  x = 20; // outer function scope\\n  let a = function divisor(y) {\\n    return x / y; // local scope\\n  }\\n  return a;\\n  }\\nlet a = div()\\na(4) // returns 5\\n\")), mdx(\"p\", null, \"Closure can be useful for creating private methods and freeing up the global scope. However, unnecessary closures will slow down performance.\"), mdx(\"h2\", {\n    \"id\": \"global-and-local-scope\"\n  }, \"Global and Local Scope\"), mdx(\"p\", null, \"Inner scopes can access variables in outer scopes (including the Global Scope i.e. window). Outer scopes on the other hand cannot access variables from inner scopes. Within an inner scope, variables within the local scope take priority over variables in the outer scope.\"), mdx(\"p\", null, \"For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"let re = 10; // the Global scope variable\\nfunction d() {\\n  let re = 45; // the Local scope variable\\n  return re;\\n}\\nd(); // when function d is called, the returned value is 45\\n\")), mdx(\"h2\", {\n    \"id\": \"function-scope-and-block-scope\"\n  }, \"Function Scope and Block Scope\"), mdx(\"p\", null, \"Function scope uses the var keyword, which allows the function to access variables inside inner functions.\"), mdx(\"p\", null, \"Block scope uses the let keyword, only allowing an outer function to access only its own local variables (hiding those contained inside inner functions).\"), mdx(\"h2\", {\n    \"id\": \"window-object\"\n  }, \"Window Object\"), mdx(\"p\", null, \"The window represents the global scope. Variables declared with var in the global scope can be accessed through the window object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"var we = 10;\\nwindow.we; // returns 10 \\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Coding Blog"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"45b6317f-d19a-53a2-8819-c3dd7e871b5e","excerpt":"What is Closure Closure allows a function to reference values outside its scope. Closure is the function and its local variables stored for…","slug":"/scope-and-closure","title":"Scope and Closure","date":"October 21, 2019","siteTitle":"Coding Blog","socialLinks":[{"name":"twitter","url":"https://twitter.com/"},{"name":"github","url":"https://github.com/hakod"}],"previous":null,"next":{"node":{"id":"ec97a1cc-ab50-580e-91cf-a4e53c53738e","excerpt":"The concurrency model describes how a programming language executes code independent of order to achieve improved performance. Modern…","slug":"/event-loop","title":"Event Loop","date":"October 22, 2019"}}}}}